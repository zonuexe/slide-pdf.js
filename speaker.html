<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <base href="./">
  <title>Speaker View</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #0f0f0f;
      color: #f5f5f5;
    }
    body {
      display: flex;
    }
    .speaker-layout {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      padding: 1.5rem;
      box-sizing: border-box;
      width: 100%;
      height: 100%;
    }
    .preview-row {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      min-height: 0;
    }
    .preview-tile {
      background: #161616;
      border-radius: 12px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      min-height: 0;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
    }
    .preview-title {
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 600;
      color: #b5b5b5;
    }
    .preview-frame {
      flex: 1;
      background: #050505;
      border-radius: 0.75rem;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      min-height: 0;
      position: relative;
    }
    .preview-canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      background: #000;
    }
    .speaker-clock {
      font-size: 3rem;
      text-align: center;
      font-variant-numeric: tabular-nums;
      font-weight: 600;
      margin-top: auto;
    }
    .speaker-rabbit-panel {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      padding: 1rem;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.05);
      box-shadow: 0 10px 26px rgba(0, 0, 0, 0.35);
    }
    .speaker-rabbit-row {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .speaker-rabbit-panel label {
      font-size: 0.9rem;
      font-weight: 600;
      color: #c0c0c0;
    }
    .speaker-rabbit-input {
      width: 5rem;
      padding: 0.4rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(0, 0, 0, 0.3);
      color: inherit;
      font-size: 1rem;
    }
    .speaker-rabbit-input:focus-visible {
      outline: 2px solid #7dd3fc;
      outline-offset: 2px;
    }
    .speaker-rabbit-button {
      padding: 0.45rem 1rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: #7dd3fc;
      color: #05121a;
      font-weight: 600;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    .speaker-rabbit-button:hover,
    .speaker-rabbit-button:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(125, 211, 252, 0.5);
      outline: none;
    }
    .speaker-rabbit-status {
      font-size: 0.85rem;
      color: #d1d5db;
      min-height: 1.2rem;
    }
    .speaker-channel-indicator {
      font-size: 0.8rem;
      text-align: center;
      color: #7dd3fc;
      opacity: 0.85;
      transition: opacity 0.2s ease-in-out;
    }
    .speaker-channel-indicator.hidden {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body class="speaker-view">
  <div class="speaker-layout" id="js-speaker-root">
    <div class="preview-row">
      <div class="preview-tile">
        <div class="preview-title" id="js-speaker-current-label">現在: -</div>
        <div class="preview-frame">
          <canvas class="preview-canvas" id="js-speaker-current-canvas"></canvas>
        </div>
      </div>
      <div class="preview-tile">
        <div class="preview-title" id="js-speaker-next-label">次: -</div>
        <div class="preview-frame">
          <canvas class="preview-canvas" id="js-speaker-next-canvas"></canvas>
        </div>
      </div>
    </div>
    <div class="speaker-clock" id="js-speaker-clock">--:--:--</div>
    <div class="speaker-rabbit-panel">
      <div class="speaker-rabbit-row">
        <label for="js-speaker-rabbit-duration">Rabbit timer (minutes)</label>
        <input
          id="js-speaker-rabbit-duration"
          class="speaker-rabbit-input"
          type="number"
          inputmode="decimal"
          min="0.1"
          step="0.1"
          placeholder="5"
          value="5"
        />
        <label for="js-speaker-rabbit-interval">Turtle step (sec)</label>
        <input
          id="js-speaker-rabbit-interval"
          class="speaker-rabbit-input"
          type="number"
          inputmode="decimal"
          min="1"
          step="1"
          placeholder="5"
          value="5"
        />
        <label for="js-speaker-rabbit-sprite">Character</label>
        <select id="js-speaker-rabbit-sprite" class="speaker-rabbit-input speaker-rabbit-select">
          <option value="elephpant" selected>Elephpant</option>
          <option value="turtle">Rabbit turtle</option>
        </select>
        <button id="js-speaker-rabbit-start" class="speaker-rabbit-button" type="button">Start Rabbit</button>
      </div>
      <div id="js-speaker-rabbit-status" class="speaker-rabbit-status" aria-live="polite">Timer idle.</div>
    </div>
    <div class="speaker-channel-indicator" id="js-speaker-channel">channel: connecting…</div>
  </div>
  <noscript>Enable JavaScript to use the speaker view.</noscript>
  <script type="module">
    import * as pdfjsLib from './node_modules/pdfjs-dist/build/pdf.mjs';

    const params = new URLSearchParams(window.location.search);
    const handshake = params.get('handshake') || undefined;
    const pdfUrl = params.get('slide');
    const channelIndicator = document.getElementById('js-speaker-channel');
    const currentLabel = document.getElementById('js-speaker-current-label');
    const nextLabel = document.getElementById('js-speaker-next-label');
    const currentCanvas = document.getElementById('js-speaker-current-canvas');
    const nextCanvas = document.getElementById('js-speaker-next-canvas');
    const clockElement = document.getElementById('js-speaker-clock');
    const rabbitDurationInput = document.getElementById('js-speaker-rabbit-duration');
    const rabbitIntervalInput = document.getElementById('js-speaker-rabbit-interval');
    const rabbitStartButton = document.getElementById('js-speaker-rabbit-start');
    const rabbitSpriteSelect = document.getElementById('js-speaker-rabbit-sprite');
    const rabbitStatus = document.getElementById('js-speaker-rabbit-status');

    let pdfDoc = null;
    let currentPage = 1;
    let nextPage = null;
    let totalPages = 0;
    let renderTasks = { current: null, next: null };

    pdfjsLib.GlobalWorkerOptions.workerSrc = new URL('./pdf.worker.mjs', import.meta.url).toString();

    const defaultChannelText = 'channel: connecting…';
    const updateChannel = (
      text,
      { highlight = false, pulse = false, hideAfter = false, force = false } = {}
    ) => {
      if (!channelIndicator) {
        return;
      }
      const shouldHide = !force && (!text || text === 'channel: synced');
      if (shouldHide) {
        channelIndicator.textContent = '';
        channelIndicator.classList.add('hidden');
        channelIndicator.classList.remove('pulse', 'green', 'amber', 'red');
        return;
      }
      channelIndicator.classList.remove('hidden');
      channelIndicator.textContent = text;
      channelIndicator.classList.toggle('pulse', Boolean(pulse));
      if (highlight) {
        channelIndicator.classList.add('green');
        channelIndicator.classList.remove('amber', 'red');
      } else {
        channelIndicator.classList.remove('green');
      }
      if (hideAfter) {
        setTimeout(() => {
          if (channelIndicator.textContent === text) {
            channelIndicator.textContent = '';
            channelIndicator.classList.add('hidden');
          }
        }, 800);
      }
    };
    updateChannel(defaultChannelText, { force: true });

    // 時計の更新
    const formatter = new Intl.DateTimeFormat(undefined, {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
    const updateClock = () => {
      if (clockElement) {
        clockElement.textContent = formatter.format(new Date());
      }
    };
    updateClock();
    setInterval(updateClock, 1000);

    const formatRabbitDuration = (ms) => {
      if (!Number.isFinite(ms) || ms < 0) {
        return '--:--';
      }
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    };

    const updateRabbitPanelStatus = (text, state = 'idle', extras = {}) => {
      if (!rabbitStatus) return;
      let nextText = text;
      if ((!nextText || !nextText.trim()) && state === 'running') {
        if (typeof extras.elapsedMs === 'number' && typeof extras.durationMs === 'number') {
          nextText = `Timer: ${formatRabbitDuration(extras.elapsedMs)} / ${formatRabbitDuration(extras.durationMs)}`;
        } else {
          nextText = 'Timer running…';
        }
      }
      if ((!nextText || !nextText.trim()) && state === 'completed') {
        nextText = 'Timer completed.';
      }
      rabbitStatus.textContent = nextText;
      rabbitStatus.dataset.state = state;
    };

    const requestRabbitTimerStart = () => {
      if (!(rabbitDurationInput instanceof HTMLInputElement)) {
        updateRabbitPanelStatus('Rabbit timer unavailable.', 'error');
        return;
      }

      const minutesValue = Number.isNaN(rabbitDurationInput.valueAsNumber)
        ? Number.parseFloat(rabbitDurationInput.value)
        : rabbitDurationInput.valueAsNumber;

      let intervalSeconds = Number.isNaN(rabbitIntervalInput?.valueAsNumber ?? Number.NaN)
        ? Number.parseFloat(rabbitIntervalInput?.value ?? '')
        : rabbitIntervalInput?.valueAsNumber;

      if (!Number.isFinite(intervalSeconds) || intervalSeconds <= 0) {
        intervalSeconds = 5;
      }

      if (!Number.isFinite(minutesValue) || minutesValue <= 0) {
        updateRabbitPanelStatus('Enter a positive number of minutes.', 'error');
        rabbitDurationInput.focus();
        rabbitDurationInput.select();
        return;
      }

      if (!window.opener || window.opener.closed) {
        updateRabbitPanelStatus('Host window unavailable.', 'error');
        return;
      }

      try {
        const spriteValue =
          rabbitSpriteSelect instanceof HTMLSelectElement ? rabbitSpriteSelect.value : 'elephpant';
        window.opener.postMessage(
          {
            type: 'speaker-rabbit-start',
            handshake,
            minutes: minutesValue,
            intervalSeconds,
            sprite: spriteValue
          },
          window.location.origin
        );
        updateRabbitPanelStatus(`Requested Rabbit timer: ${minutesValue} min`, 'running', {
          elapsedMs: 0,
          durationMs: minutesValue * 60 * 1000
        });
      } catch (error) {
        console.error('Failed to request Rabbit timer', error);
        updateRabbitPanelStatus('Could not send Rabbit timer request.', 'error');
      }
    };

    if (rabbitStartButton instanceof HTMLButtonElement) {
      rabbitStartButton.addEventListener('click', requestRabbitTimerStart);
    }
    const rabbitInputs = [rabbitDurationInput, rabbitIntervalInput, rabbitSpriteSelect];
    rabbitInputs.forEach((input) => {
      if (input instanceof HTMLInputElement) {
        input.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            requestRabbitTimerStart();
          }
        });
      }
    });

    // キーボードイベントをホストに転送
    const handleKeydown = (event) => {
      if (event.shiftKey || event.ctrlKey || event.metaKey || event.altKey) {
        return;
      }
      const navKeys = ['ArrowLeft', 'ArrowDown', 'k', 'a', 'K', 'A', 'PageUp',
                      'ArrowRight', 'ArrowUp', 'j', 's', 'J', 'S', 'PageDown'];
      if (navKeys.includes(event.key) && window.opener && !window.opener.closed) {
        try {
          window.opener.postMessage({
            type: 'speaker-keydown',
            handshake,
            key: event.key
          }, window.location.origin);
        } catch (error) {
          console.error('Failed to send keydown event', error);
        }
      }
    };
    window.addEventListener('keydown', handleKeydown);
    document.addEventListener('keydown', handleKeydown);

    // PDF読み込み
    async function loadPDF(url) {
      try {
        updateChannel('channel: loading PDF…', { force: true });
        const loadingTask = pdfjsLib.getDocument({
          url: url,
          cMapUrl: new URL('./cmaps/', import.meta.url).toString(),
          cMapPacked: true
        });
        pdfDoc = await loadingTask.promise;
        totalPages = pdfDoc.numPages;
        updateChannel('channel: PDF loaded', { highlight: true, pulse: true, hideAfter: true, force: true });
        return true;
      } catch (error) {
        console.error('Failed to load PDF', error);
        updateChannel('channel: error - PDF load failed', { force: true });
        return false;
      }
    }

    // ページのレンダリング
    async function renderPreview(role, pageNumber, canvas, label) {
      if (!canvas || !label) return;

      const cancelTask = (task) => {
        if (task) {
          try {
            task.cancel();
          } catch {
            /* no-op */
          }
        }
      };

      cancelTask(renderTasks[role]);
      renderTasks[role] = null;

      if (!pdfDoc || !pageNumber) {
        label.textContent = role === 'current' ? '現在: -' : '次: (終端)';
        const ctx = canvas.getContext('2d');
        if (ctx) {
          drawFallback(role, ctx, canvas);
        }
        return;
      }

      try {
        const page = await pdfDoc.getPage(pageNumber);
        const bounds = canvas.parentElement;
        const maxWidth = bounds?.clientWidth ?? Math.max(window.innerWidth / 2, 200);
        const maxHeight = bounds?.clientHeight ?? Math.max(window.innerHeight * 0.6, 200);
        const baseViewport = page.getViewport({ scale: 1 });
        const widthScale = maxWidth / baseViewport.width;
        const heightScale = maxHeight / baseViewport.height;
        const scale = Math.max(Math.min(widthScale, heightScale), 0.1);
        const viewport = page.getViewport({ scale });
        const outputScale = window.devicePixelRatio ?? 1;

        canvas.width = Math.max(Math.floor(viewport.width * outputScale), 1);
        canvas.height = Math.max(Math.floor(viewport.height * outputScale), 1);
        canvas.style.width = `${viewport.width}px`;
        canvas.style.height = `${viewport.height}px`;

        const context = canvas.getContext('2d');
        if (!context) return;

        context.setTransform(1, 0, 0, 1, 0, 0);
        context.fillStyle = '#fff';
        context.fillRect(0, 0, canvas.width, canvas.height);

        const renderContext = {
          canvasContext: context,
          viewport
        };
        if (outputScale !== 1) {
          renderContext.transform = [outputScale, 0, 0, outputScale, 0, 0];
        }

        label.textContent = role === 'current'
          ? `現在: ${pageNumber}/${totalPages}`
          : `次: ${pageNumber}/${totalPages}`;

        const renderTask = page.render(renderContext);
        renderTasks[role] = renderTask;
        try {
          await renderTask.promise;
        } catch (error) {
          if (error?.name !== 'RenderingCancelledException') {
            throw error;
          }
        } finally {
          if (renderTasks[role] === renderTask) {
            renderTasks[role] = null;
          }
        }
      } catch (error) {
        console.error(`Failed to render ${role} preview`, error);
        label.textContent = role === 'current' ? '現在: エラー' : '次: エラー';
      }
    }

    function drawFallback(role, context, canvas) {
      const width = canvas.parentElement?.clientWidth ?? Math.max(window.innerWidth / 2, 200);
      const height = canvas.parentElement?.clientHeight ?? Math.max(window.innerHeight * 0.6, 200);
      const ratio = window.devicePixelRatio ?? 1;
      canvas.width = Math.max(Math.floor(width * ratio), 1);
      canvas.height = Math.max(Math.floor(height * ratio), 1);
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;

      context.fillStyle = '#3a3a3a';
      context.fillRect(0, 0, canvas.width, canvas.height);
      context.fillStyle = '#8a8a8a';
      context.font = `${Math.round(canvas.height / 8)}px -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif`;
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      const message = role === 'current' ? 'ページ情報なし' : '次のページなし';
      context.fillText(message, canvas.width / 2, canvas.height / 2);
    }

    // リサイズ時の更新
    let resizeTimeout = null;
    window.addEventListener('resize', () => {
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeTimeout = setTimeout(() => {
        if (pdfDoc) {
          renderPreview('current', currentPage, currentCanvas, currentLabel);
          renderPreview('next', nextPage, nextCanvas, nextLabel);
        }
      }, 100);
    });

    // メッセージハンドリング
    window.addEventListener('message', async (event) => {
      if (event.origin !== window.location.origin) {
        return;
      }
      const data = event.data;
      if (!data || typeof data !== 'object') {
        return;
      }

      if (data.type === 'speaker-navigation-update' && data.handshake === handshake) {
        currentPage = data.currentPage ?? 1;
        nextPage = data.nextPage ?? null;
        totalPages = data.totalPages ?? 0;

        if (data.pdfUrl && (!pdfDoc || data.pdfUrl !== pdfUrl)) {
          await loadPDF(data.pdfUrl);
        }

        await Promise.all([
          renderPreview('current', currentPage, currentCanvas, currentLabel),
          renderPreview('next', nextPage, nextCanvas, nextLabel)
        ]);
        updateChannel('', { force: false });
        return;
      }

      if (data.type === 'speaker-ack' && data.handshake === handshake) {
        updateChannel('channel: acknowledged', { pulse: true, hideAfter: true, force: true });
        try {
          event.source?.postMessage({
            type: 'speaker-log',
            handshake,
            message: 'Speaker view received ack'
          }, event.origin);
        } catch (error) {
          console.error('Failed to confirm speaker ack', error);
        }
        return;
      }

      if (data.type === 'rabbit-timer-status' && data.handshake === handshake) {
        updateRabbitPanelStatus(data.message ?? '', data.state ?? 'idle', data);
        if (typeof data.intervalSeconds === 'number' && rabbitIntervalInput instanceof HTMLInputElement) {
          rabbitIntervalInput.value = String(data.intervalSeconds);
        }
        if (typeof data.minutes === 'number' && rabbitDurationInput instanceof HTMLInputElement) {
          rabbitDurationInput.value = String(data.minutes);
        }
        if (data.sprite && rabbitSpriteSelect instanceof HTMLSelectElement) {
          rabbitSpriteSelect.value = data.sprite;
        }
        return;
      }

      if (data.type === 'speaker-ping' && data.handshake === handshake) {
        const label = data.label ? ` ${data.label}` : '';
        updateChannel('', { force: false });
        try {
          event.source?.postMessage({
            type: 'speaker-pong',
            handshake,
            label: data.label,
            timestamp: Date.now()
          }, event.origin);
        } catch (error) {
          console.error('Failed to respond to ping', error);
        }
      }
    });

    // ホストに ready を送信
    const notify = (attempt = 0) => {
      try {
        if (!window.opener) {
          if (attempt < 100) {
            window.requestAnimationFrame(() => notify(attempt + 1));
          } else {
            console.error('Speaker view: window.opener is not available.');
            updateChannel('channel: error - no opener', { force: true });
          }
          return;
        }
        if (window.opener.closed) {
          console.warn('Speaker view: parent window is closed.');
          updateChannel('channel: parent closed', { force: true });
          return;
        }
        updateChannel('channel: waiting for host…', { force: true });
        window.opener.postMessage({ type: 'speaker-ready', handshake }, window.location.origin);
      } catch (error) {
        console.error('Speaker view notify error:', error);
        if (attempt < 100 && error.name !== 'SecurityError') {
          window.requestAnimationFrame(() => notify(attempt + 1));
        } else {
          updateChannel('channel: error - ' + error.message, { force: true });
        }
      }
    };

    const scheduleNotify = () => {
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(() => notify(), 0);
      } else {
        window.addEventListener('load', notify, { once: true });
        document.addEventListener('DOMContentLoaded', () => notify(), { once: true });
      }
    };

    scheduleNotify();
  </script>
</body>
</html>
